# analysis/isotopomer.py
# ---------------------------------------------------------------------
# Corrected version incorporating fixes for initialization and parsing.
# Handles positional product indices referring to reactant order.
# ---------------------------------------------------------------------
from __future__ import annotations

import re
import warnings
from collections import defaultdict
from typing import Dict, List, Tuple, Sequence, Iterable, TYPE_CHECKING
import numpy as np # Make sure numpy is imported

# Prevent circular import for type checking if MetabolicModel is imported
if TYPE_CHECKING:
    # Assuming MetabolicModel is in the specified path
    from models.metabolism import MetabolicModel


class IsotopomerHandler:
    """
    Parse atom-mapping strings such as

        GLC[1,2,3,4,5,6] -> LAC[3,2,1] + LAC[6,5,4]
        PYR[1,2,3] -> ACCOA[?,1,2]

    and supply the **fractional enrichment (FE)** of every product
    carbon that is generated by every reaction.

    Handles '?' as a source of natural abundance (0.011).
    Handles positional mapping on product side (e.g., -> PROD[1,2])
    referring to the order of reactant carbons listed (1st reactant C, 2nd reactant C).
    """

    _MAPPING_PATTERN = re.compile(
        r"([A-Za-z][A-Za-z0-9_]*)\[(.*?)\]"  # Allow underscores in names
    )  # captures "GLC_ext[1,2,3]" -> ('GLC_ext','1,2,3')
    _NATURAL_ABUNDANCE = 0.011  # Approx. 13C natural abundance

    # ------------------------------------------------------------------
    # public construction helpers
    # ------------------------------------------------------------------
    @classmethod
    def from_metabolic_model(cls, model: "MetabolicModel") -> "IsotopomerHandler":
        """
        Convenience constructor. Reads data from the MetabolicModel structure.

        Parameters
        ----------
        model : MetabolicModel
            An instance of the MetabolicModel class from models.metabolism
        """
        if not hasattr(model, 'reactions') or not hasattr(model, 'metabolites'):
             raise TypeError("Provided model object does not have expected 'reactions' or 'metabolites' attributes.")

        reactions = list(model.reactions.keys())
        atom_mapping_strs = {}
        missing_mappings = []

        for r_id, reaction_data in model.reactions.items():
            # *** Assumes 'atom_mapping_str' key exists in reaction dict ***
            if 'atom_mapping_str' in reaction_data:
                 atom_mapping_strs[r_id] = reaction_data['atom_mapping_str']
            else:
                 missing_mappings.append(r_id)

        if missing_mappings:
             raise ValueError(f"Original atom mapping string ('atom_mapping_str') not found "
                              f"in MetabolicModel.reactions dictionary for reactions: {missing_mappings}. "
                              f"Ensure it's stored during model definition in models/metabolism.py (add_reaction).")

        metabolite_carbons = {}
        for met_id, details in model.metabolites.items():
             metabolite_carbons[met_id] = details.get('carbon_count', 0)

        # Call the main constructor with the extracted arguments
        return cls(
            reactions=reactions,
            atom_mapping_strs=atom_mapping_strs,
            metabolite_carbons=metabolite_carbons,
        )

    # ------------------------------------------------------------------
    # object life-cycle
    # ------------------------------------------------------------------
    def __init__(
        self,
        reactions: Sequence[str],
        atom_mapping_strs: Dict[str, str],
        metabolite_carbons: Dict[str, int],
    ):
        """
        Initializes the handler by parsing all mapping strings.
        """
        self.reactions = list(reactions)
        self.metabolite_carbons = metabolite_carbons
        # mapping[rxn_idx] -> List[(prod_met, prod_pos, Optional[reac_met], Optional[reac_pos])]
        self._mapping: List[List[Tuple[str, int, str | None, int | None]]] = []

        if not isinstance(atom_mapping_strs, dict):
             raise TypeError(f"Expected atom_mapping_strs to be a dict, got {type(atom_mapping_strs)}")
        if not isinstance(metabolite_carbons, dict):
              raise TypeError(f"Expected metabolite_carbons to be a dict, got {type(metabolite_carbons)}")

        for r_id in self.reactions:
            mapping_str = atom_mapping_strs.get(r_id)
            if mapping_str is None:
                raise KeyError(f"Atom mapping string not provided for reaction: {r_id}")
            try:
                 parsed_map = self._parse_mapping(mapping_str) # Use the corrected parser below
                 self._mapping.append(parsed_map)
            except Exception as e:
                 raise ValueError(f"Error parsing mapping string for reaction '{r_id}': '{mapping_str}'\n -> {e}") from e

    # ------------------------------------------------------------------
    # core public API
    # ------------------------------------------------------------------
    def calculate_labeling_fluxes_all(
        self,
        fractional_enrichment: Dict[str, List[float] | np.ndarray], # Allow numpy arrays
    ) -> List[Dict[str, List[float]]]:
        """
        Calculate the *instantaneous* FE of every carbon formed
        in each reaction based on current reactant enrichments.
        """
        all_results: List[Dict[str, List[float]]] = []
        if len(self._mapping) != len(self.reactions):
             raise RuntimeError(f"Internal state mismatch: mapping length ({len(self._mapping)}) "
                                f"doesn't match reaction count ({len(self.reactions)}).")

        for i, rxn_map in enumerate(self._mapping):
            rxn_id = self.reactions[i]
            prod_fe_template: Dict[str, List[float]] = defaultdict(list)
            product_mets_in_rxn = {prod_met for prod_met, *_ in rxn_map}

            for prod_met in product_mets_in_rxn:
                nC = self.metabolite_carbons.get(prod_met)
                if nC is None:
                     warnings.warn(f"Product metabolite '{prod_met}' in reaction '{rxn_id}' not found in carbon count dictionary.")
                     continue
                prod_fe_template[prod_met] = [0.0] * nC

            for prod_met, prod_pos, reac_met, reac_pos in rxn_map:
                if prod_met not in prod_fe_template: continue

                fe_source = self._NATURAL_ABUNDANCE
                if reac_met is not None and reac_pos is not None:
                    if reac_met not in fractional_enrichment:
                         warnings.warn(f"Reactant '{reac_met}' enrichment data not provided for reaction '{rxn_id}'. Assuming natural abundance source.")
                    else:
                         fe_vector = fractional_enrichment[reac_met]
                         if not (1 <= reac_pos <= len(fe_vector)):
                              warnings.warn(f"Reactant '{reac_met}' carbon position {reac_pos} out of bounds for provided FE data (len={len(fe_vector)}) in reaction '{rxn_id}'. Assuming natural abundance source.")
                         else:
                              fe_source = fe_vector[reac_pos - 1]

                if not (1 <= prod_pos <= len(prod_fe_template[prod_met])):
                      warnings.warn(f"Product '{prod_met}' carbon position {prod_pos} is out of bounds (nC={len(prod_fe_template[prod_met])}) in reaction '{rxn_id}'. Skipping assignment.")
                else:
                     prod_fe_template[prod_met][prod_pos - 1] = fe_source

            all_results.append(dict(prod_fe_template))
        return all_results

    # ------------------------------------------------------------------
    # implementation helpers
    # ------------------------------------------------------------------
    def _parse_mapping(
        self, mapping_str: str
    ) -> List[Tuple[str, int, str | None, int | None]]:
        """
        Parses mapping string like 'A[1,2] + B[3] -> C[A1,B3] + D[A2]'
        or 'A[1,2,3]->B[?,A1,A2]'
        or positional referring to reactant order 'LAC[1,2,3] -> GLU_g[?,?,1,2,3]'

        Returns
        -------
        mapping
            List of (product_met, product_pos, reactant_met | None, reactant_pos | None)
            Reactant info is None if the source was '?'.
        """
        # (Corrected parser that handles positional product indices referencing reactant order)
        if not mapping_str or "->" not in mapping_str:
            raise ValueError("Mapping string must contain '->' and be non-empty.")

        reactant_part, product_part = mapping_str.split('->', 1)
        reactant_part = reactant_part.strip()
        product_part = product_part.strip()

        # --- Parse Reactants & Build Source Map ---
        reactants_parsed: List[Tuple[str, List[int]]] = []
        reactant_carbon_map: Dict[str, Tuple[str, int]] = {} # Map 'MetIDIndex' -> (MetID, Index)
        flat_reactant_carbons: List[Tuple[str, int]] = [] # Ordered list of (met_id, c_index)
        if reactant_part:
            reactant_matches = re.findall(r'([A-Za-z0-9_]+)\[([^\]]+)\]', reactant_part)
            if not reactant_matches: raise ValueError(f"Could not parse reactant part: '{reactant_part}'")
            for name, idx_str in reactant_matches:
                try:
                     split_indices = [c.strip() for c in idx_str.split(',') if c.strip()]
                     idxs = [int(i) for i in split_indices]
                     if len(idxs) != len(split_indices): raise ValueError("contains non-integer")
                except ValueError as ve: raise ValueError(f"Invalid reactant indices '{idx_str}' for '{name}'. {ve}")
                reactants_parsed.append((name, idxs))
                for idx in idxs:
                    source_key = f"{name}{idx}"
                    reactant_carbon_map[source_key] = (name, idx)
                    flat_reactant_carbons.append((name, idx))

        # --- Parse Products ---
        products_parsed: List[Tuple[str, List[str]]] = [] # Store origins as strings
        flat_product_origins: List[Tuple[str, str]] = [] # Ordered list of (met_id, origin_str)
        if product_part and product_part != '?':
            product_matches = re.findall(r'([A-Za-z0-9_]+)\[([^\]]+)\]', product_part)
            if not product_matches: raise ValueError(f"Could not parse product part: '{product_part}'. Expected MET[...] or '?'.")
            for name, origin_str in product_matches:
                origins = [o.strip() for o in origin_str.split(',') if o.strip()]
                if not origins: raise ValueError(f"Empty origin list for product '{name}'")
                products_parsed.append((name, origins))
                for o_str in origins:
                     flat_product_origins.append((name, o_str))
        elif product_part == '?': pass # Handle efflux later
        elif not product_part: pass # RHS is empty
        # else: Should not happen


        # --- Build Final Mapping ---
        mapping: List[Tuple[str, int, str | None, int | None]] = []
        product_pos_tracker = defaultdict(int)

        # Handle efflux case "A[1,2] -> ?" -> return empty map
        if product_part == '?':
            return mapping # Efflux means no tracked products are formed

        for i, (p_met, p_origin_str) in enumerate(flat_product_origins):
            product_pos_tracker[p_met] += 1
            p_pos = (product_pos_tracker[p_met] - 1) % self.metabolite_carbons[p_met] + 1 # Corrected pos within molecule

            if p_origin_str == '?':
                mapping.append((p_met, p_pos, None, None))
            elif p_origin_str in reactant_carbon_map:
                # Origin is explicitly defined (e.g., 'GLC1')
                r_met, r_pos = reactant_carbon_map[p_origin_str]
                mapping.append((p_met, p_pos, r_met, r_pos))
            elif p_origin_str.isdigit():
                 # *** MODIFIED LOGIC for Positional Index ***
                 # Interpret digit as 1-based index into the ordered reactant carbons
                try:
                    reactant_idx_1_based = int(p_origin_str)
                    if 1 <= reactant_idx_1_based <= len(flat_reactant_carbons):
                         # Get the corresponding reactant carbon details
                         r_met, r_pos = flat_reactant_carbons[reactant_idx_1_based - 1] # Use 0-based index
                         mapping.append((p_met, p_pos, r_met, r_pos))
                    else:
                         raise ValueError(f"Positional index '{reactant_idx_1_based}' is out of range "
                                          f"for the {len(flat_reactant_carbons)} reactant carbons listed.")
                except ValueError: # Should not happen if isdigit() is true, but for safety
                     raise ValueError(f"Could not interpret positional index '{p_origin_str}'.")

            else:
                # Origin is not '?', not explicit, and not a parsable positional digit
                raise ValueError(
                    f"Origin '{p_origin_str}' for product '{p_met}' (instance position {p_pos}) in mapping '{mapping_str}' "
                    f"does not match any reactant carbon ({list(reactant_carbon_map.keys())}), '?', "
                    f"or a valid positional index digit."
                )

        # Final check on total counts (optional)
        # ... (warning code remains the same) ...

        return mapping